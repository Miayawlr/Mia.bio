import Layout from 'lib/components/layout'
import { Spacer, Link, Dot } from '@geist-ui/react'

export const meta = {
  title: 'JavaScript事件循环',
  date: '2021-02-05T05:00:41.510Z',
  description: '',
}

本文将会以`javaScript`到底是怎么在引擎中工作的为切入点,挖掘其中的原理。本文将尽可能的做到深入浅出。

`javaScript`作为一个单线程的语言运载在浏览器的 v8 引擎之下。(这里不做`node`环境的讨论)这就意味着我们不可能同时并行执行,所有的任务都是逐行执行的。这便意味着,
`javaScript`代码都是同步并且阻塞的。但是我们可以通过其他方式让代码异步执行。在浏览器这个宿主环境下,他为我们提供了一个`setTimeout()`的 API。通过这个 API 我们可以
让我们的代码在指定的时间后执行。

```javaScript
console.log('message 1')

setTimeout(()=>{
  console.log('message 2')
},1000)

console.log('message 3')
//res => 1=>3=>2
```

上面代码片段的执行结果通过注释我们可以得知运行的结果。在确保所有的异步代码在同步代码执行之后执行,这便是事件循环的由来。可能这么说还不是很形象。
这里引用一段视频阐述<Link href="https://www.bilibili.com/video/BV1a4411F7t7" color icon>_eventloop_</Link>

#### 1.堆栈

- 在`javaScript`中,我们定义的变量,数据类型都是分别存在这个名为堆栈的区间内。这时候代码通过解析器已经在开始逐行执行了。在 _Stack_(栈)空间中,我们所有的`javaScript`代码
  都将一个个的被推送进这个容器并且在执行完弹出。这有点类似于`scopeChain`。这时候如果使用`promise`,`setTimeout`等一系列异步方法。那么这些代码将会被移交到事件列表(消息队列),
  等待主线程执行完毕再从挂起的状态重新加入到这个事件循环当中。

- 关于`javaScript`有一个极端的说法,万物皆为对象。因为类型都是通过包装类这一个概念生成的。诸如`Number(1)`和 `1`是一样的。那么我们可以极端点的推断当程序开始定义的时候所有的
  内存分配都是在*Heap*(堆)中执行的。(注:不能这么理解。)

#### 2.队列

在理解`eventloop`之前,我们可以把队列拆分成几个片段。`Callback Queue`(回调队列)、`Job Queue`(任务队列)。

- `CallbackQueue`,回调队列正如字面的意思,当你有一段异步代码要执行的时候,把他丢进队列中等待线程执行完成在执行。

- `JobQueue`,相当于主线程中执行的任务。执行主线程任务的时候他是逐行执行的,当我们遇到`Promise`的时候,就需要使用`then`方法去执行,这便是回调方法。
  一旦`Promise`解析完毕,`then`方法将把他列入任务队列(`Job Queue`)中执行。

### 3.事件循环

在盘点完队列的概念后,这里将引入事件循环(_eventloop_)这一概念,作为本文的重点。 任务队列其实就像一个环形跑道,在某些特定的区域预留了几个出口,遵循着先进先出的原则。
如果主线程执行完毕,回调队列有任务则会弹出到主线程执行,执行完毕便清空。然后事件循环不停的在查找直至所有代码执行完毕。这时候便有了宏任务,微任务的概念。关于宏任务,
微任务网上的博客对其的阐述过多,本文也不做阐述。我们只需要知道一点在事件循环这个闭环中如果存在微任务,微任务是会在宏任务执行之前执行的。

```javaScript

const val = new Promise((resolve)=>{
  console.log(0)
  resolve(1)
})

val.then((res)=>{
  console.log(res)
  console.log(2)
 new Promise((resolve)=>{
   console.log(3)
   resolve(4)
 }).then((res)=>console.log(res))
 return Promise.resolve(5)
}).then((res)=>console.log(res))

```

上面的结果很简单是按顺序输出 0,1,2,3,4,5。正如上文所描述的一样微任务是会在宏任务之前执行的。我们知道`Promise`是同步的,那么在我们定义 val 的时候其实我们就是在主线程上执行了一段同步代码,
当我们通过`resolve`或者`reject`改变了`Promise`的状态的时候并且用上了`then`这时候我们就往`callback Queue`队列中注入了 1 个任务等收到通知在弹出到主线程中执行。在前面我说过微任务是会在
宏任务之前执行的。正如这段代码片段所展示的一样。`Promise then`作为微任务,代码在依次往下执行的时候,第一个`then`里面开启了一个微任务肯定是会优先于`resolve(5)`那段的逻辑的。所谓的事件循环无非
也就是消息处理的一种模型罢了。

#### 3.面向 es7 以后的事件循环

`javaScript`在不断演变的过程中诞生了基于`generator`和`promise`的语法糖`async`和`await`。让我们的异步代码更加优雅同时可以以类同步的方式解决异步`Promise`带来的链式调用地狱。

```javaScript

const func =async()=>{
  console.log(1)
  await null
  console.log(3)
}
func()
console.log(2)

//res => 1 2 3

```

正如所提到的那样,利用`async`这一个特性让我们异步代码更加优雅,你可以把加了`await`关键字之前的代码类似于`new Promise`没有改变`pending`状态时的代码。`await`就相当于`then`。当我们遇到
`await`的时候正如上面代码片段`await null`那样 暂停了函数的执行,往队列中增加个可用的任务。这时候`func`便退出挂起等待主线程执行完毕再通知他从队列中取出到主线程执行。于是我们
分别按顺序打印出了*1,2,3*

#### 4.小结

本文本着深入浅出的概念对`eventloop`进行解析,奈何作者水平过于真实无法按照文章的初衷,只能做到全盘托出,尽可能地做到能理解什么是事件循环。

<Spacer y={3} />

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
