import Layout from 'lib/components/layout'
import { Spacer, Link, Dot } from '@geist-ui/react'

export const meta = {
  title: 'JavaScript事件循环',
  date: '2021-02-05T05:00:41.510Z',
  description: '',
}

本文将会以`javaScript`到底是怎么在引擎中工作的为切入点,挖掘其中的原理。本文将尽可能的做到深入浅出。

`javaScript`作为一个单线程的语言运载在浏览器的 v8 引擎之下。(这里不做`node`环境的讨论)这就意味着我们不可能同时并行执行,所有的任务都是逐行执行的。这便意味着,
`javaScript`代码都是同步并且阻塞的。但是我们可以通过其他方式让代码异步执行。在浏览器这个宿主环境下,他为我们提供了一个`setTimeout()`的 API。通过这个 API 我们可以
让我们的代码在指定的时间后执行。

```javaScript
console.log('message 1')

setTimeout(()=>{
  console.log('message 2')
},1000)

console.log('message 3')
//res => 1=>3=>2
```

上面代码片段的执行结果通过注释我们可以得知运行的结果。在确保所有的异步代码在同步代码执行之后执行,这便是事件循环的由来。可能这么说还不是很形象。
这里引用一段视频阐述<Link href="https://www.bilibili.com/video/BV1a4411F7t7" color icon>_eventloop_</Link>

#### 1.堆栈

- 在`javaScript`中,我们定义的变量,数据类型都是分别存在这个名为堆栈的区间内。这时候代码通过解析器已经在开始逐行执行了。在 _Stack_(栈)空间中,我们所有的`javaScript`代码
  都将一个个的被推送进这个容器并且在执行完弹出。这有点类似于`scopeChain`。这时候如果使用`promise`,`setTimeout`等一系列异步方法。那么这些代码将会被移交到事件列表(消息队列),
  等待主线程执行完毕再从挂起的状态重新加入到这个事件循环当中。

- 关于`javaScript`有一个极端的说法,万物皆为对象。因为类型都是通过包装类这一个概念生成的。诸如`Number(1)`和 `1`是一样的。那么我们可以极端点的推断当程序开始定义的时候所有的
  内存分配都是在*Heap*(堆)中执行的。(注:不能这么理解。)

#### 2.队列

在理解`eventloop`之前,我们可以把队列拆分成几个片段。`Callback Queue`(回调队列)、`Job Queue`(任务队列)。

- `CallbackQueue`,回调队列正如字面的意思,当你有一段异步代码要执行的时候,把他丢进队列中等待线程执行完成在执行。

- `JobQueue`,相当于主线程中执行的任务。执行主线程任务的时候他是逐行执行的,当我们遇到`Promise`的时候,就需要使用`then`方法去执行,这便是回调方法。
  一旦`Promise`解析完毕,`then`方法将把他列入任务队列(`Job Queue`)中执行。

### 3.事件循环

在盘点完队列的概念后,这里将引入事件循环(_eventloop_)这一概念,作为本文的重点。 任务队列其实就像一个环形跑道,在某些特定的区域预留了几个出口,遵循着先进先出的原则。
如果主线程执行完毕,回调队列有任务则会弹出到主线程执行,执行完毕便清空。然后事件循环不停的在查找直至所有代码执行完毕。这时候便有了宏任务,微任务的概念。关于宏任务,
微任务网上的博客对其的阐述过多,本文也不做阐述。我们只需要知道一点在事件循环这个闭环中如果存在微任务,微任务是会在宏任务执行之前执行的。(注:不够严谨)

<!-- 所谓的环形跑道代表着 `javaScript` 这个机器会不停的运行查找调用栈,遵循任务一一对应。(当前任务被执行了,就不会被其他任务中断) -->

<!-- 这里稍加补充事件循环 2 条基本原则:

1. 一次只执行一个任务。
2. 一个任务开始后直到运行完成， 不会被其他任务中断。 -->

```javaScript

const val = new Promise((resolve)=>{
  console.log(0)
  resolve(1)
})

val.then((res)=>{
  console.log(res)
  console.log(2)
 new Promise((resolve)=>{
   console.log(3)
   resolve(4)
 }).then((res)=>console.log(res))
 return Promise.resolve(5)
}).then((res)=>console.log(res))
console.log('全局任务')

//res =>0,'全局任务',1,2,3,4,5

```

- 快速一览:
  <div>
    <p>
      <Link href="/posts/eventloopAndJobQueue#promise" underline>
        <Dot style={{ marginRight: '5px' }} type="error" />
        <code>Promise</code>到底算宏任务还是微任务
      </Link>
    </p>
    <p>
      <Link href="/posts/eventloopAndJobQueue#eventloop" underline>
        <Dot style={{ marginRight: '5px' }} type="warning" />
        事件循环机制补充
      </Link>
    </p>
    <p>
      <Link href="/posts/eventloopAndJobQueue#resolve" underline>
        <Dot style={{ marginRight: '5px' }} type="success" />
        代码解析
      </Link>
    </p>
  </div>

> ##### 1.我理解中的 Promise<a name="promise"></a>
>
> `promise`期约函数,是`javaScript`为了解决回调地狱推出的一种异步解决方案,有 3 种状态`pending,resolve，reject`,
> 在我们在兑现承诺前(不改变 pending 状态)代码是同步执行的,属于宏任务。但是当我们更替了 pending 状态对函数兑现承诺的时候,
> 则会以期约异步的方式`then`添加`callback Queue`,属于微任务。

<!-- 全局来看上面这段代码,我们知道`promise`在兑现承诺前是同步执行的。通过期约异步的方式`then`添加`callback Queue`。那么在我们定义 val 的时候其实我们就是在主线程上执行了一段同步代码。
`event loop`首先会检查宏任务队列直至任务队列为空,这时候`promise`在兑现承诺前是一个宏任务推入宏任务队列执行,打印`0`并且往下继续执行通过`resolve`改变了期约,
同时任务继续往下执行查找打印`全局任务`。这时候我们的任务队列已经完全置空了。

这时候事件循环将会去处理微任务队列。于是我们便依次打印了`1`,`2`。这时候往下继续是一个新的`promise`他会被加入到宏任务队列执行打印`3`,`4`。这时候我我们往下执行便打印出了`5`。
当微任务队列处理完成并清空时， 事件循环会检查是否需要更新 UI
渲染,如果是,则会重新渲染 UI 视图。至此,当前事件循环结束,之后将回到最初第一个环节,再次检查宏任务队列,并开启新一轮的事件循环。 -->

> ##### 2.eventloop 详解<a name="eventloop"></a>
>
> 上文,我们简单的了解了`eventloop`类似一个环形跑道,但是正如上文我们并不清楚所谓的事件循环到底是什么,只是有个很模糊的概念,微任务是会在宏任务执行之前执行的。
> 这段解析将会从本质上剖析`eventloop`。
>
> - 事件循环基于 2 个基本的原则:
>
> 1. 一次只执行一个任务。
> 2. 一个任务开始后直到运行完成， 不会被其他任务中断。
>
> 在一次任务队列中会在这个环形跑道中查找任务执行,也就是`eventloop`会优先查找到宏任务队列,如果宏任务等待,则会执行宏任务。
> 直到该任务执行完毕(或宏任务队列为空),这时`eventloop`将会去查找微任务队列如果有微任务队列则执行微任务,`eventloop`开始依次执行,直至队列中所有的微任务执行完毕。
> 注意处理宏任务和微任务队列之间的区别:最多处理一个宏任务(其余的在队列中等待), 而队列中的所有微任务都会被处理。同时会检查是否更新 UI 渲染,至此,当前事件循环结束,之后将回到最初第一个环节,
> 再次检查宏任务队列,并开启新一轮的事件循环。

> ##### 3.代码解析<a name="resolve"></a>
>
> 上文,我们写了一段简单的代码片段,包含了一个事件循环的小 demo。这里将解释他是如何运作的。
> 通过先前的知识,我们得知了`promise`的具体执行方式,因此很容易的按照执行环境上下文依次往下执行,不懂执行级上下文的同学可以参照<Link href="/posts/closuresAndScope" color icon></Link>配合食用。
> 所以这时候会按照顺序打印`0，全局任务`。这时候在我们打印*0*的时候依次往下执行对`promise`做出了承诺这时候我们往微任务队列加入任务等待执行。
> 同时任务继续往下执行查找打印`全局任务`。这时候我们的宏任务队列已经完全置空了。这时候开始执行微任务队列,代码也将依次往下执行分别打印`1,2`,这时候一个新的`promise`加入到宏任务队列执行打印`3`,期约改变加入
> 微任务队列这时会打印`4`,代码依次往下执行，`then`返回新的 `promise `链式调用微任务执行打印`5`这时候所有的微任务执行完毕。由于我们这段代码不涉及 UI 视图中间 UI 视图的变更也不做描述。

#### 3.面向 es7 以后的事件循环

`javaScript`在不断演变的过程中诞生了基于`generator`和`promise`的语法糖`async`和`await`。让我们的异步代码更加优雅同时可以以类同步的方式解决异步`Promise`带来的链式调用地狱。

```javaScript

const func =async()=>{
  console.log(1)
  await null
  console.log(3)
}
func()
console.log(2)

//res => 1 2 3

```

正如所提到的那样,利用`async`这一个特性让我们异步代码更加优雅,你可以把加了`await`关键字之前的代码类似于`new Promise`没有改变`pending`状态时的代码。`await`就相当于`then`。当我们遇到
`await`的时候正如上面代码片段`await null`那样 暂停了函数的执行,往队列中增加个可用的任务。这时候`func`便退出挂起等待主线程执行完毕再通知他从队列中取出到主线程执行。于是我们
分别按顺序打印出了*1,2,3*

#### 4.小结

本文本着深入浅出的概念对`eventloop`进行解析,奈何作者水平过于真实无法按照文章的初衷,只能做到全盘托出,如果不对欢迎指正,尽可能地做到能理解什么是事件循环。

<Spacer y={3} />

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
