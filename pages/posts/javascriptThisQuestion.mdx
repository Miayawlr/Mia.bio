import Layout from 'lib/components/layout'
import { Spacer, Link, Dot, Description, Code } from '@geist-ui/react'

export const meta = {
  title: 'this指向的一文指北(js)',
  date: '2021-01-27T02:27:57.690Z',
  description: '',
}

`JavaScript`是一门极其美观的语言,正是因为它具有灵活随意的特点,
对于这一特性,我们往往又爱又恨,在以往的文章中我已分析过`javaScript`2 个难点,诸如:_闭包_、_原型链_。

从本文开始,我将阐述`JavaScript`另外一位嘉宾`this`。说到`this`,老生常谈的问题就是`this`指向往往让我们头疼不已,
本博文的宗旨就是在以最小的`demo`阐述原理。

#### 1.离开 es6 的 this 指向

```js
function Test() {
  console.log(this)
}
Test.prototype.func = function () {
  console.log(this) //test这个实例
}
Test() //window
const test = new Test() //test这个实例
```

上面这段代码桥段是属于`es5`中的构造函数,在我们通过*new*实例化的时候初始化了一个对象。代码段的`this`指向都指向了注释的地方。
具体的解释可以先参照之前的文章<Link href="/posts/whatIsPrototype#menu" color>原型链详解</Link>
相信上文的解释已经解释了`this`的指向。那么在对象中他又是什么样的一个姿态。

```js
const obj = {
  name: 3,
  getName() {
    console.log(this) //obj
    console.log(this.name) //3
  },
}
obj.getName()
```

这段代码并没有什么难理解的地方,对象正如之前提到的构造函数那样。把`this`牢牢的挂载在了这个载体上,至于为什么我要叫他载体,因为`obj`作为一个实例,
之前的`test`也是一个实例。那么我们就可以得出一个不怎么靠谱的结论。在对象里面,我们`this`的指向始终指向了这个实例。
接下来要施展一点魔术,不用担心这会改变你对`this`的认知。

```js
const obj = {
  name: 3,
  getName() {
    console.log(this.name)
  },
}

var name = 9
obj.getName() //3
obj.getName.apply(this, [name]) //9
obj.getName.call(this, name) //9
```

通过`apply`和`call`我们会惊讶的发现我们输出的数据并不是 3 而是 9,因为我们通过了`call`和`apply`改变了函数的上下文。我们姑且可以把全局执行环境`GO`看成一个大的`scope`。
因此我们把`this`的指向挂载到了全局也就是改变了所谓的`this`指向。因此我们得到的答案是 9 而不是 3。

#### 2.es6 以后的 this 指向

`es6`作为现代 `JavaScript`的基石,能降低我们的心智负担,同时能让我们编写更优雅的代码。因此诞生了本文讨论的箭头函数`()=>{}`,箭头函数可以减少我们对`this`的依赖。但是在和`es5`的`function`混用时明显会加剧一定的心智负担。

```js
var name = 'global'

const obj = {
  name: 'obj',
  getName() {
    function func() {
      console.log(this.name)
    }
    func()
  },
  getName2() {
    const func = () => console.log(this.name)
    func()
  },
}

obj.getName() //global
obj.getName2() //obj
```

上面的代码我们通过`obj.getName()`无法得到期望的*obj*而是`global`。但是我们如果使用箭头函数去做处理,就像`obj.getName2()`这样,我们可以获取到
期望的*obj*。因为箭头函数本身是没有`this`的(未绑定)同时也无`arguments`。而是从定义时的函数继
承上下文。

### 3. 顺带一提

在编写`JavaScript`中,我是十分青睐函数式编程的,因此列举出和本文有些许关系的`this`调用的小实例。

```js
const useMemo = (f) => {
  const pool = {}
  return function () {
    const arg = JSON.stringify(arguments)
    pool[arg] = pool[arg] || f.apply(f, arguments)
    return pool[arg]
  }
}

const multiply = (x, y) => x * y
console.log(useMemo(multiply)(2, 3)) //6
console.log(useMemo(multiply)(2, 3)) //6
```

上面的 demo 我们利用了 `apply` 和函数自身的缓存功能帮助我们缓存了函数以便下次调用更快获取结果。

<Spacer y={3} />

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
