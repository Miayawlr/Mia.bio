import Layout from 'lib/components/layout'
import { Spacer, Card } from '@geist-ui/react'

export const meta = {
  title: 'javaScript作用域与闭包的前世今生1',
  date: '2020-11-26T14:14:48.051Z',
  description: '',
}

在学习使用`JavaScript`的时候,我们通常对代码的执行顺序没有考虑过他到底是怎么样运行的,
通常按照我们的惯性思维他是从上往下执行的例如下面这一段代码块。

```js
var a = 3
const func = () => {
  console.log('hello world')
}
func()
console.log(a)
```

可是当我们面对一些奇形怪状的面试题难免有些力不从心,我将通过下面一段代码块,带你了解其中的原理。

```js
console.log(a)
var a = 3
function a() {
  console.log('hello world')
}
```

#### 1.AO/GO

这里我要引入 AO/GO 的概念让你理解这上面这段代码块他到底干了些什么。

- AO(Activation Object)活动对象
- GO(Global Object) 全局对象

概念补充:

- GO 1.会优先查找全局的变量 2.寻找函数声明 3.最后执行->编译。
- AO 1.会优先查找函数形参和变量声明 2.实参赋值给形参 3.寻找找函数声明赋值 4.执行

下面来看这么一段推导

```js
首先代码执行的时候,通过我们自身的知识储备我们可以看到var a=3 因此他被提升了。这时候就相当于开启了
GO。有的朋友可能对var不是很理解,这里讲解下var a= 3相当于
var a
a =3
这时候我们可以把上面的代码块理解成
var a
function a(){
  console.log('hello world')
}
console.log(a)
a=3
GO:{
  a:undefined
  a:function a(){}
  a:3
}
这是变量a的在GO中的变化。
我们的代码块你可与理解为他有4层,第一层在我们使用var的时候提升了,
赋予初始值undefined,
然后通过GO的原则寻找函数声明,
这时候我们已经把a从undefined变成了function a 。这时候我们就执行到了第二层然后遇到了第三层
的console.log(a),a作为func就被打印了。
```

经过上面的小试牛刀相信对 GO 的概念 有了初步的了解。那么我讲继续引导你对 GO/AO 的理解。

#### 2.作用域

在理解作用域前,我想谈下*Object*的概念, `javaScript` 的数据类型分成这样引用类型,数值类型,在`javaScript`中
,`function`也具有*Object*的特性,既然是对象,他就会有例如 `function.name`等方法，这里不做讨论,
当然还有一些属性是我们无法访问到的 JS 引擎内部固有的隐式属性,这里我将列举`[scope]`的概念。

`scope`[域]是`JavaScript`中一个重要的概念,这里我将承接上文的 AO/GO 的概念带你初步了解什么是`scope`
,什么是 `scope Chain`_作用域链_。

<Card hoverable>
  <h7>PartⅡ</h7>
  <p>
    接上文AO/GO的概念,这里我将补充2个新的概念关于AO/GO的,不用担心他会对你之前的认知带来困扰
  </p>
  <p>AO 拥有执行上下文函数的能力</p>
  <p>GO 全局函数执行上下文</p>
  函数在执行完成以后,AO是会被销毁的,即AO是一个即使存储容器。
</Card>

这里我将演示一段代码段

```js
function a() {
  function b() {
    var b = 2
    console.log(a) // 1
  }
  var a = 1
  b()
}
var c = 3
a()
console.log(c)
```

这一是一段常见的`javaScript`代码,分别输出`1`,`3`。
通过上文谈到的 AO/GO 我们再分析一下

```js
var c //undefined
function a() {}
c = 3
//这时候的GO环境
GO: {
  c: undefined
  a: function a() {} //这时候生成了作用域链scope chain
}

//遇到function a 执行AO
AO: {
  a: undefined ->1
  b: undefined ->function b(){}
}
当函数a被执行时(执行的前一刻),作用域链的顶端(第0位)存储到a函数生成的函数执行上下文AO,同时第一位存储GO,查找变量是到a
函数存储的作用域顶端开始依次往下查找。这时候我们看看a函数的AO中发生了一些什么。
a函数的AO:{
  a:undefined ->1
  b:undefined ->function b(){}
}
这时候a函数内的AO结构就清晰了。这时候函数b被定义开启了函数b的ao 这里忽略结构
当b函数被定义时,是在a函数环境下,所以b函数这时候的作用域链就是a函数被执行期的作用域链。
此时当b函数被执行,生成函数b的scope,位于顶端0
这时的scope china
b()
a()
global()
因此b会优先寻找自身的AO变量定义。
```

上文便是通过利用 AO/GO 的概念进行推导的一段代码块,通过上面的推导,我相信各位同学们都能理解其中的奥妙。

#### 3.思考与观察

对于域的思考需要反复大量的认读与实际开发的积累,上文所述的无非是对知识的一遍梳理,多观察平常自己写的代码去发现其中 AO/GO 的构造,这就是观察与思考。

<Spacer y={3} />

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
