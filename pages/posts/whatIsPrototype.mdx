import Layout from 'lib/components/layout'
import { Spacer, Link, Dot, Description, Code } from '@geist-ui/react'

export const meta = {
  title: 'javaScript中的原型链',
  date: '2020-12-05T09:21:05.499Z',
  description: '',
}

在学习`JavaScript`的时候,通常令我们感到困惑的有闭包,原型链。他们作为`JavaScript`的基石,决定了我们上限的高度。
它的本质是 `JavaScript` 开发的理论基础和技术提升的踏板。在此我想通过我的理解帮助同学们跨过这座大山。

在学习`JavaScript`原型链之前。我想带同学们了解下什么是构造函数。

#### 1. 通过现象看本质

现有一块代码段如下

```js
function Test(name, age) {
  this.name = name
  this.age = age
}
Test.prototype.getName = function () {
  console.log(this.name)
}

const test = new Test('miaya', 18)
test.getName()
```

- 思考与分析
  <div>
    <p>
      <Dot style={{ marginRight: '5px' }} type="error" />
      在实例化之前其中的this指向了谁?
    </p>
    <p>
      <Dot style={{ marginRight: '5px' }} type="warning" />
      new这个关键字做了什么?
    </p>
    <p>
      <Dot style={{ marginRight: '5px' }} type="success" />
      prototype到底是什么?
    </p>
  </div>

带着上述的疑问我将带同学们一起思考其中的问题。代码块如下

```js
//  在实例化之前其中的this指向了谁
function Test() {
  this.name = name
  this.age = age
  console.log(this) // window。
  //实例化以后 打印 Test {name :'miaya',18 }
}
Test()
```

<Description
  title="探究this指向了谁"
  content={
    <>
      <div
        style={{
          fontSize: '1.2em',
          fontWeight: 'normal',
          lineHeight: '1.525em',
        }}
      >
        通过上述的打印我们可以清楚的看到Test构造函数在实例化之前
        this指向的是window。 那么我们在实例化之后呢?
        <Code> const test = new Test('miaya', 18)</Code>
        为什么在new 之后this就改变了指向呢?其实是因为构造函数会隐式
        的返回一个this。 例如下面的这一段伪代码。
      </div>
    </>
  }
/>

```js
function Test() {
  var this = {
    this.name : name
    this.age : age
  }
  return this
}
```

我们通过 return this 将 this 返回给了实例。因此,我们定义的 test 接收到的这个
this 实例实际上就是 test 本身。这里有的同学可能会疑惑了,你说 rerun this 那就是 return this 吗?
这里我将再列举一段代码。通过结果在看本质。

```js
function Return(name) {
  this.name = name
  console.log(this) // Return {name :'miaya'}
  return {}
}

const ret = new Return('miaya')
console.log(ret) //{}
```

我们可以看到打印的 ret 并未我们想得到的 name 值。这里我们同时在 retrun 前打印 this。
我们可以清楚的看到 this 还是指向到了这个实例。但是我们 retrun 了一个空对象,
让一切都不符合了预期。
这里同学们就该相信实际上我们这个构造函数他就是隐式的 return 了一个 this。
这里也将补充一个其他的知识点。普通函数默认 return 的是 undefined。
通过上面的学习,我们知道了 new 的作用实际上就是把这个 this 挂载给了实例本身。

<Description
  title="prototype 是个啥"
  content={
    <>
      <div
        style={{
          fontSize: '1.2em',
          fontWeight: 'normal',
          lineHeight: '1.525em',
        }}
      >
        我们可以打印下 Test 构造函数的 prototype
        <Code> console.log(test)</Code>
        <br />
        <Code>console.log(Test.prototype)</Code>
        <br />
        通过打印我们可以得到分别一个实例产物和 constructor。 同学们可以打开这个实例我们可以清楚的看到一个名为__proto__的属性。同时里面也包含了我们的打印的
        constructor 和挂载的方法。 这里我将借助对象的概念通过一段伪代码帮助同学们理解
        prototype 干了些什么。
      </div>
    </>
  }
/>

- 接上文

```js
function Test() {
  var this = {
    this.name : name
    this.age : age
    __proto__ :{
      getName,
      constructor
    }
  }
  return this
}

Test.prototype.getName = function () {
  console.log(this.name)
}

const test = new Test('miaya', 18)
console.log(test)
console.log(Test.prototype)
```

如上文的伪代码块。我们可以把`__proto__`理解为我们 return 出去的 this 的一个键名。
我们通过 prototype 就是往这个键里面添加属性。
因此我们打印出来的结果分别对应了我们的猜想。同学们不必把`__proto__`想象的有多复杂。
纵观太多的博客博文都是故弄玄虚的把这么一个属性神话到一个让我们无法理解他究竟是什么。
其实他很简单,只需要把他理解成一个系统内置的属性键名就好了。至于为什么要用`__proto__`呢。
也许他的本意是想让我们不去调用他吧。

#### 2.有点简单的多人关系。

通过上面的小试牛刀。我想各位同学已经对构造函数有了初步了理解。那么我将成热打铁,带你窥探原型链其中的关系。
有一段代码段如下

```js
function Grasp() {
  this.name = 'Grasp'
}
Grasp.prototype.grasp = function () {
  console.log('grasp prototype')
}

function Learn() {
  this.name = 'Learn'
  this.counter = 100
}
Learn.prototype.learn = function () {
  console.log('learn prototype')
}

function Test(name) {
  this.name = name
}

let grasp = new Grasp()
let learn = new Learn()

Learn.prototype = grasp
Learn.prototype = Grasp.prototype
Test.prototype = learn
Test.prototype = Learn.prototype
let test = new Test('miaya')
console.log(test)
```

通过打印 test 我们可以清晰的看到其中`__proto__`的结构。无一例外指向到了 Grasp 的实例。
同时也继承了上面的属性和方法。但是我们得思考一下这么做真的好吗?

- 思考与分析
  <div>
    <p>
      <Dot style={{ marginRight: '5px' }} type="error" />
      可否通过实例修改继承的属性和方法?
    </p>
    <p>
      <Dot style={{ marginRight: '5px' }} type="warning" />
      怎么用更优雅的方式实现继承?
    </p>
  </div>

带着上述的问题我将带着同学们一起思考,代码块如下

```js
 首先我们往构造函数Learn 里面添加一段代码
 function Learn(){
   this.obj={
     js:'1',
   }
 }
 test.obj.ts='2'
 test.counter++
console.log(learn)
console.log(test)
```

<Description
  title="有点奇怪的修改"
  content={
    <>
      <div
        style={{
          fontSize: '1.2em',
          fontWeight: 'normal',
          lineHeight: '1.525em',
        }}
      >
        通过上述的打印我们可以看到一个现象。实例test中保存了counter 101,
        实例learn中保存了counter 100。同时实例learn中obj的属性被添加了。
        通过打印我们可以看到obj被保存到test实例的__proto__里面。而counter被保存到了自身实例里。
        方法的修改这里就不做演示 。
        因此我们可以得到一个结论我们可以通过实例去修改继承的属性和方法。
        但是如果我们修改的是一个引用类型那么他只会保存到__proto__里面而不是在这个实例上(也就是
        <s>this</s>),对此我们产生了思考能否用一种优雅的方式实现继承呢。
      </div>
    </>
  }
/>
<Spacer y={1} />
<Description
  title="优雅的继承"
  content={
    <>
      <div
        style={{
          fontSize: '1.2em',
          fontWeight: 'normal',
          lineHeight: '1.525em',
        }}
      >
        面对上面的困扰我们能否使用一种优雅的方式去实现呢?
        这里我将列举2种方式进行演示,为各位同学们选择合理的方式去实现如何优雅的继承。
      </div>
    </>
  }
/>

```js
// 组合继承
function Grasp() {
  this.graspNmae = 'grasp'
}
Grasp.prototype.grasp = function () {
  console.log('grasp prototype')
}
function Learn() {
  this.learnName = 'learn'
  Grasp.call(this)
}
Learn.prototype.constructor = Grasp
Learn.prototype = new Grasp()
function Test {
  Learn.call(this)
}
Test.prototype = new Learn()
Test.prototype.constructor =Test
let test = new Test()
console.log(test)
```

通过打印我们可以清楚的看到我们调用了父类的构造函数。同时生成了多份实例,这显然是对性能的浪费。
这里有的同学可能不懂为什么要把 constructor 指向自身。这其实是一种习惯。并无其他用处。
这里的 <Code>Test/Learn 的 prototype=new Grasp()/new Learn()</Code>其实相当于
我门把这个实例挂载到了对应的`__proto__`上。对应的`call`相当于把 this 的指向改变到当前的实例上。
因此我们得到了一份同样的实例。但是由于我们通过`call`方式我们无法实现使用`prototype`的方法和属性,因此
我们就需要把`prototype`也一并挂载。

<p>
  <Dot style={{ marginRight: '5px' }} type="success" />
  能否更优雅?
</p>
为了解决组合继承带来的性能浪费,因此就诞生了组合寄生式继承。

```js
function Father(age) {
  this.age = age
}
Father.prototype.getAge = function () {
  console.log(this.age)
}
function Children(age, name) {
  Father.call(this, age, name)
  this.name = name
}
function Buffer() {}
Buffer.prototype = Father.prototype
Children.prototype = new Buffer()
Children.prototype.constructor = Children
Children.prototype.super_class = Father.name //可以清楚的知道继承了谁
let children = new Children('18', 'miaya')
Children.prototype.getName = function () {
  console.log(this.name)
}
console.log(children)
children.getName()
children.getAge()
```

通过上面的代码段我们优雅的继承了父类的一切同时通过打印 children 发现并没有性能的浪费。

- 逐步分析
  <div>
    <p>
      <Dot style={{ marginRight: '5px' }} type="error" />
      构造函数Buffer的用处是什么?
    </p>
    <p>
      <Dot style={{ marginRight: '5px' }} type="warning" />
      为什么要这么写?
    </p>
  </div>

<Description
  title="优雅的缓冲区"
  content={
    <>
      <div
        style={{
          fontSize: '1.2em',
          fontWeight: 'normal',
          lineHeight: '1.525em',
        }}
      >
        通过前面的知识我们可以得知,在构造函数Children中我们通过call/apply改变了实例this的指向。
        因此这个实例指向到了chilren。让我们可以优雅的实例化一切。Buffer作为一个缓冲区,我们使用Buffer的
        prototype 接收 父类的prototype 相当于如下所示。
      </div>
    </>
  }
/>

```js
function Buffer() {
  var this = {
    __proto__: Father.__proto__,
  }
  return this
}
```

`Children.prototype` 挂载了 Buffer 的实例就相当于

```js
function Children() {
  var this = {
    __proto__: new Buffer(),
  }
  return this
}
这里的这个Buffer指的是Buffer这个实例。
```

因此我们通过之前的知识可以得知,即使我们往 Children 的 `prototype`追加方法或者属性
,他终将挂载在我们的缓冲区中并未对我们的父类造成影响,这就实现了我们优雅的继承。

<Spacer y={3} />

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
